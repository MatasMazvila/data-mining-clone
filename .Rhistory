set.seed(123)
k_values_means <- 2:15
wss_means_cj <- sapply(k_values_means, function(k) {
kmeans_result_cj <- kmeans(kmeans_data_cj_means, centers = k, nstart = 25)
kmeans_result_cj$tot.withinss
})
# Plot the Elbow Curve
plot(k_values_means, wss_means_cj, type = "b", pch = 19, frame = FALSE,
xlab = "Number of Clusters (k)",
ylab = "Total Within-Cluster Sum of Squares (WSS)",
main = "Elbow Method for K-Means (Commenters Jaccard)")
wss_means_cj <- sapply(k_values_means, function(k) {
kmeans_result_cj <- kmeans(kmeans_data_cj_means, centers = k, nstart = 25)
kmeans_result_cj$tot.withinss
})
# Plot the Elbow Curve
plot(k_values_means, wss_means_cj, type = "b", pch = 19, frame = FALSE,
xlab = "Number of Clusters (k)",
ylab = "Total Within-Cluster Sum of Squares (WSS)",
main = "Elbow Method for K-Means (Commenters Jaccard)")
# Silhouette for K-Means
set.seed(123)
silhouette_scores_means_cj <- sapply(k_values_means, function(k) {
kmeans_result_cj <- kmeans(kmeans_data_cj_means, centers = k, nstart = 25)
silhouette_result_cj <- silhouette(kmeans_result_cj$cluster, distance_matrix_cj_means)
mean(silhouette_result_cj[, 3])
})
# Plot Silhouette Scores
plot(k_values_means, silhouette_scores_means_cj, type = "b", pch = 19, frame = FALSE,
xlab = "Number of Clusters (k)",
ylab = "Average Silhouette Score",
main = "Silhouette Method for K-Means (Commenters Jaccard)")
# Run K-Means
k_cj_means <- 4 # elbow - 4, silhouette - 4
kmeans_result_cj <- kmeans(kmeans_data_cj_means, centers = k_cj_means, nstart = 25)
# Add cluster labels to the dataset
kmeans_data_cj_means$cluster <- as.factor(kmeans_result_cj$cluster)
# Visualize the clusters
ggplot(kmeans_data_cj_means, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3, hjust = 0.5, vjust = -0.5, check_overlap = TRUE) +
labs(
title = "K-Means Clustering (Commenters Jaccard)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal()
# Ensure that information and distance matrix line up
stopifnot(all(channel_info$title == commenters_jaccard$title))
# Define similarity as matrix
similarity_matrix_gbc_cj <- as.matrix(commenters_jaccard[, -1])
# Remove dimnames to avoid warnings
rownames(similarity_matrix_gbc_cj) <- NULL
colnames(similarity_matrix_gbc_cj) <- NULL
# Create a graph from the Jaccard similarity matrix
graph_gbc_cj <- similarity_matrix_gbc_cj %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
# Perform community detection using the Louvain method
community_result_gbc_cj <- cluster_louvain(graph_gbc_cj)
modularity_score <- modularity(community_result_gbc_cj)
cat("Modularity Score:", modularity_score, "\n")
# Precompute graph
graph_gbc_cj <- similarity_matrix_gbc_cj %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
# Louvain clustering result
community_result_gbc_cj <- cluster_louvain(graph_gbc_cj)
# Convert community structure to dendrogram (hclust-like object)
dendrogram_gbc_cj <- as.hclust(community_result_gbc_cj)
# Define range of cluster numbers to explore
k_values <- 2:15  # Adjust the range based on your data
modularity_scores <- sapply(k_values, function(k) {
# Cut dendrogram into k clusters
clusters_gbc_cj <- cutree(dendrogram_gbc_cj, k = k)
# Compute modularity for the given number of clusters
modularity(graph_gbc_cj, clusters_gbc_cj)
})
distance_matrix <- distances(graph_gbc_cj, weights = E(graph_gbc_cj)$weight)
silhouette_score <- silhouette(cluster_memberships_gbc_cj, as.dist(distance_matrix))
avg_silhouette_score <- mean(silhouette_score[, 3])
cat("Average Silhouette Score:", avg_silhouette_score, "\n")
# Ensure that information and distance matrix line up
stopifnot(all(channel_info$title == commenters_jaccard$title))
# Define similarity as matrix
similarity_matrix_gbc_cj <- as.matrix(commenters_jaccard[, -1])
# Remove dimnames to avoid warnings
rownames(similarity_matrix_gbc_cj) <- NULL
colnames(similarity_matrix_gbc_cj) <- NULL
# Create a graph from the Jaccard similarity matrix
graph_gbc_cj <- similarity_matrix_gbc_cj %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
# Perform community detection using the Louvain method
community_result_gbc_cj <- cluster_louvain(graph_gbc_cj)
# Compute the modularity score to check clustering quality
modularity_score <- modularity(community_result_gbc_cj)
cat("Modularity Score:", modularity_score, "\n")
# Extract cluster memberships
cluster_memberships_gbc_cj <- membership(community_result_gbc_cj)
# Add cluster labels to the dataset
channel_info$gbc_cluster_cj <- cluster_memberships_gbc_cj
# MDS-based visualization
mds_coords_gbc_cj <- cmdscale(as.dist(1 - similarity_matrix_gbc_cj), k = 2)
visualization_data_gbc_cj <- data.frame(
X1 = mds_coords_gbc_cj[, 1],
X2 = mds_coords_gbc_cj[, 2],
cluster = as.factor(cluster_memberships_gbc_cj)
)
ggplot(visualization_data_gbc_cj, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Commenters Jaccard)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
# Ensure that information and distance matrix line up
stopifnot(all(channel_info$title == commenters_jaccard$title))
# Define similarity as matrix
similarity_matrix_gbc_cj <- as.matrix(commenters_jaccard[, -1])
# Remove dimnames to avoid warnings
rownames(similarity_matrix_gbc_cj) <- NULL
colnames(similarity_matrix_gbc_cj) <- NULL
# Create a graph from the Jaccard similarity matrix
graph_gbc_cj <- similarity_matrix_gbc_cj %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
# Perform community detection using the Louvain method
community_result_gbc_cj <- cluster_louvain(graph_gbc_cj)
# Compute the modularity score to check clustering quality
modularity_score <- modularity(community_result_gbc_cj)
cat("Modularity Score:", modularity_score, "\n")
# Extract cluster memberships
cluster_memberships_gbc_cj <- membership(community_result_gbc_cj)
# Add cluster labels to the dataset
channel_info$gbc_cluster_cj <- cluster_memberships_gbc_cj
# MDS-based visualization
mds_coords_gbc_cj <- cmdscale(as.dist(1 - similarity_matrix_gbc_cj), k = 2)
visualization_data_gbc_cj <- data.frame(
X1 = mds_coords_gbc_cj[, 1],
X2 = mds_coords_gbc_cj[, 2],
cluster = as.factor(cluster_memberships_gbc_cj)
)
ggplot(visualization_data_gbc_cj, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Commenters Jaccard)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
stopifnot(all(channel_info$title == commenters_overlap$title))
similarity_matrix_gbc_co <- as.matrix(commenters_overlap[, -1])
rownames(similarity_matrix_gbc_co) <- NULL
colnames(similarity_matrix_gbc_co) <- NULL
graph_gbc_co <- similarity_matrix_gbc_co %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
community_result_gbc_co <- cluster_louvain(graph_gbc_co)
modularity_score <- modularity(community_result_gbc_co)
cat("Modularity Score:", modularity_score, "\n")
cluster_memberships_gbc_co <- membership(community_result_gbc_co)
channel_info$gbc_cluster_co <- cluster_memberships_gbc_co
mds_coords_gbc_co <- cmdscale(as.dist(1 - similarity_matrix_gbc_co), k = 2)
visualization_data_gbc_co <- data.frame(
X1 = mds_coords_gbc_co[, 1],
X2 = mds_coords_gbc_co[, 2],
cluster = as.factor(cluster_memberships_gbc_co)
)
ggplot(visualization_data_gbc_co, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Commenters Overlap)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
stopifnot(all(channel_info$title == subs_jaccard$title))
similarity_matrix_gbc_sj <- as.matrix(subs_jaccard[, -1])
rownames(similarity_matrix_gbc_sj) <- NULL
colnames(similarity_matrix_gbc_sj) <- NULL
graph_gbc_sj <- similarity_matrix_gbc_sj %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
community_result_gbc_sj <- cluster_louvain(graph_gbc_sj)
modularity_score <- modularity(community_result_gbc_sj)
cat("Modularity Score:", modularity_score, "\n")
cluster_memberships_gbc_sj <- membership(community_result_gbc_sj)
channel_info$gbc_cluster_sj <- cluster_memberships_gbc_sj
mds_coords_gbc_sj <- cmdscale(as.dist(1 - similarity_matrix_gbc_sj), k = 2)
visualization_data_gbc_sj <- data.frame(
X1 = mds_coords_gbc_sj[, 1],
X2 = mds_coords_gbc_sj[, 2],
cluster = as.factor(cluster_memberships_gbc_sj)
)
ggplot(visualization_data_gbc_sj, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Subs Jaccard)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
stopifnot(all(channel_info$title == subs_overlap$title))
similarity_matrix_gbc_so <- as.matrix(subs_overlap[, -1])
rownames(similarity_matrix_gbc_so) <- NULL
colnames(similarity_matrix_gbc_so) <- NULL
graph_gbc_so <- similarity_matrix_gbc_so %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
community_result_gbc_so <- cluster_louvain(graph_gbc_so)
modularity_score <- modularity(community_result_gbc_so)
cat("Modularity Score:", modularity_score, "\n")
cluster_memberships_gbc_so <- membership(community_result_gbc_so)
channel_info$gbc_cluster_so <- cluster_memberships_gbc_so
mds_coords_gbc_so <- cmdscale(as.dist(1 - similarity_matrix_gbc_so), k = 2)
visualization_data_gbc_so <- data.frame(
X1 = mds_coords_gbc_so[, 1],
X2 = mds_coords_gbc_so[, 2],
cluster = as.factor(cluster_memberships_gbc_so)
)
ggplot(visualization_data_gbc_so, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Subs Overlap)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
#------------------------------------------------------------------------------
############## Graph-Based Clustering (GBC) ##############
#------------------------------------------------------------------------------
# Libraries
library(readr)
library(cluster)
library(ggplot2)
library(dbscan)
library(kernlab)
library(dplyr)
library(igraph)
library(mclust)
library(data.table)
library(factoextra)
library(plotly)
library(Rtsne)
library(uwot)
library(pheatmap)
library(dendextend)
library(gridExtra)
library(plotly)
#------------------------------------------------------------------------------
############## DATA ##############
#------------------------------------------------------------------------------
channel_info <- read_csv("data/channel_info.csv")
commenters_jaccard <- read_csv("data/comment_jaccard_matrix.csv")
commenters_overlap <- read_csv("data/comment_overlap_matrix.csv")
subs_jaccard <- read_csv("data/subs_jaccard_matrix.csv")
subs_overlap <- read_csv("data/subs_overlap_matrix.csv")
#------------------------------------------------------------------------------
############## Commenters Jaccard Dataset (Graph-Based Clustering) ##############
#------------------------------------------------------------------------------
# Ensure that information and distance matrix line up
stopifnot(all(channel_info$title == commenters_jaccard$title))
# Define similarity as matrix
similarity_matrix_gbc_cj <- as.matrix(commenters_jaccard[, -1])
# Remove dimnames to avoid warnings
rownames(similarity_matrix_gbc_cj) <- NULL
colnames(similarity_matrix_gbc_cj) <- NULL
# Create a graph from the Jaccard similarity matrix
graph_gbc_cj <- similarity_matrix_gbc_cj %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
# Perform community detection using the Louvain method
community_result_gbc_cj <- cluster_louvain(graph_gbc_cj)
# Compute the modularity score to check clustering quality
modularity_score <- modularity(community_result_gbc_cj)
cat("Modularity Score:", modularity_score, "\n")
# Extract cluster memberships
cluster_memberships_gbc_cj <- membership(community_result_gbc_cj)
# Add cluster labels to the dataset
channel_info$gbc_cluster_cj <- cluster_memberships_gbc_cj
# MDS-based visualization
mds_coords_gbc_cj <- cmdscale(as.dist(1 - similarity_matrix_gbc_cj), k = 2)
visualization_data_gbc_cj <- data.frame(
X1 = mds_coords_gbc_cj[, 1],
X2 = mds_coords_gbc_cj[, 2],
cluster = as.factor(cluster_memberships_gbc_cj)
)
ggplot(visualization_data_gbc_cj, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Commenters Jaccard)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
#------------------------------------------------------------------------------
############## Commenters Overlap Dataset (GBC) ##############
#------------------------------------------------------------------------------
stopifnot(all(channel_info$title == commenters_overlap$title))
similarity_matrix_gbc_co <- as.matrix(commenters_overlap[, -1])
rownames(similarity_matrix_gbc_co) <- NULL
colnames(similarity_matrix_gbc_co) <- NULL
graph_gbc_co <- similarity_matrix_gbc_co %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
community_result_gbc_co <- cluster_louvain(graph_gbc_co)
modularity_score <- modularity(community_result_gbc_co)
cat("Modularity Score:", modularity_score, "\n")
cluster_memberships_gbc_co <- membership(community_result_gbc_co)
channel_info$gbc_cluster_co <- cluster_memberships_gbc_co
mds_coords_gbc_co <- cmdscale(as.dist(1 - similarity_matrix_gbc_co), k = 2)
visualization_data_gbc_co <- data.frame(
X1 = mds_coords_gbc_co[, 1],
X2 = mds_coords_gbc_co[, 2],
cluster = as.factor(cluster_memberships_gbc_co)
)
ggplot(visualization_data_gbc_co, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Commenters Overlap)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
#------------------------------------------------------------------------------
############## Subsriber Jaccard Dataset (GBC) ##############
#------------------------------------------------------------------------------
stopifnot(all(channel_info$title == subs_jaccard$title))
similarity_matrix_gbc_sj <- as.matrix(subs_jaccard[, -1])
rownames(similarity_matrix_gbc_sj) <- NULL
colnames(similarity_matrix_gbc_sj) <- NULL
graph_gbc_sj <- similarity_matrix_gbc_sj %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
community_result_gbc_sj <- cluster_louvain(graph_gbc_sj)
modularity_score <- modularity(community_result_gbc_sj)
cat("Modularity Score:", modularity_score, "\n")
cluster_memberships_gbc_sj <- membership(community_result_gbc_sj)
channel_info$gbc_cluster_sj <- cluster_memberships_gbc_sj
mds_coords_gbc_sj <- cmdscale(as.dist(1 - similarity_matrix_gbc_sj), k = 2)
visualization_data_gbc_sj <- data.frame(
X1 = mds_coords_gbc_sj[, 1],
X2 = mds_coords_gbc_sj[, 2],
cluster = as.factor(cluster_memberships_gbc_sj)
)
ggplot(visualization_data_gbc_sj, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Subs Jaccard)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
#------------------------------------------------------------------------------
############## Subsriber Overlap Dataset (GBC) ##############
#------------------------------------------------------------------------------
stopifnot(all(channel_info$title == subs_overlap$title))
similarity_matrix_gbc_so <- as.matrix(subs_overlap[, -1])
rownames(similarity_matrix_gbc_so) <- NULL
colnames(similarity_matrix_gbc_so) <- NULL
graph_gbc_so <- similarity_matrix_gbc_so %>%
graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE, diag = FALSE)
community_result_gbc_so <- cluster_louvain(graph_gbc_so)
modularity_score <- modularity(community_result_gbc_so)
cat("Modularity Score:", modularity_score, "\n")
cluster_memberships_gbc_so <- membership(community_result_gbc_so)
channel_info$gbc_cluster_so <- cluster_memberships_gbc_so
mds_coords_gbc_so <- cmdscale(as.dist(1 - similarity_matrix_gbc_so), k = 2)
visualization_data_gbc_so <- data.frame(
X1 = mds_coords_gbc_so[, 1],
X2 = mds_coords_gbc_so[, 2],
cluster = as.factor(cluster_memberships_gbc_so)
)
ggplot(visualization_data_gbc_so, aes(x = X1, y = X2, color = cluster)) +
geom_point(size = 3) +
geom_text(aes(label = channel_info$title),
size = 3,
hjust = 0.5, vjust = -0.5,
check_overlap = TRUE) +
labs(
title = "Graph-Based Clustering with Channel Names (Subs Overlap)",
x = "MDS Dimension 1",
y = "MDS Dimension 2"
) +
theme_minimal() +
theme(
legend.position = "bottom",
plot.title = element_text(hjust = 0.5)
)
# Compute modularity scores for GBC
modularity_score_cj_gbc <- round(modularity(community_result_gbc_cj), 4)
modularity_score_co_gbc <- round(modularity(community_result_gbc_co), 4)
modularity_score_sj_gbc <- round(modularity(community_result_gbc_sj), 4)
modularity_score_so_gbc <- round(modularity(community_result_gbc_so), 4)
# Create the data frame
clustering_scores_df <- data.frame(
dataset = c("commenter jaccard", "commenter overlap", "subscriber jaccard", "subscriber overlap"),
hopkins_statistic = c(
hopkins_stat_cj,
hopkins_stat_co,
hopkins_stat_sj,
hopkins_stat_so
),
silhouette_k_medoids = c(
avg_silhouette_cj_medoids,
avg_silhouette_co_medoids,
avg_silhouette_sj_medoids,
avg_silhouette_so_medoids
),
silhouette_k_means = c(
avg_silhouette_cj_means,
avg_silhouette_co_means,
avg_silhouette_sj_means,
avg_silhouette_so_means
),
silhouette_dbscan = c(
avg_silhouette_cj_dbscan,
avg_silhouette_co_dbscan,
avg_silhouette_sj_dbscan,
avg_silhouette_so_dbscan
),
silhouette_hac = c(
avg_silhouette_cj_hac,
avg_silhouette_co_hac,
avg_silhouette_sj_hac,
avg_silhouette_so_hac
),
silhouette_hdc = c(
avg_silhouette_cj_hdc,
avg_silhouette_co_hdc,
avg_silhouette_sj_hdc,
avg_silhouette_so_hdc
),
modularity_gbc = c(
modularity_score_cj_gbc,
modularity_score_co_gbc,
modularity_score_sj_gbc,
modularity_score_so_gbc
)
)
# Print the resulting data frame
print(clustering_scores_df)
# Print the resulting data frame
print(clustering_scores_df)
# Table
library(knitr)
clustering_scores_table <- kable(
clustering_scores_df,
format = "simple",
col.names = c("Dataset", "Hopkins Statistic", "Silhouette (K-Medoids)",
"Silhouette (K-Means)", "Silhouette (DBSCAN)", "Silhouette (HAC)",
"Silhouette (HDC)", "Modularity (GBC)"),
align = c("l", "c", "c", "c", "c", "c", "c")
)
print(clustering_scores_table)
